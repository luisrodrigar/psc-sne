% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/psc_sne.R
\name{psc_sne}
\alias{psc_sne}
\title{Polyspherical Cauchy SNE}
\usage{
psc_sne(X, d, rho_psc_list = NULL, rho = 0.5, perplexity = 30,
  maxit = 1000, initial_momentum = 0.5, final_momentum = 0.8,
  eta = 200, early_exaggeration = 4, colors = NULL, show_prog = 100,
  show_plots = TRUE, tol = 1e-06,
  parallel_cores = parallel::detectCores() - 1, init = c("equispaced",
  "random", "most_promising")[1], N = 10)
}
\arguments{
\item{X}{an array of size \code{c(n, d + 1, r)} with the polyspherical data,
where \code{n} is the number of observations, \code{d} is the dimension of
each sphere, and \code{r} is the number of spheres.}

\item{d}{the target dimension to use for the reduced data of \code{X}.}

\item{rho_psc_list}{rho parameters of the high-dimensional polyspherical
Cauchy probabilities. Multiple types of parameters are allowed,
distinguishing three scenarios. The first one when the type of the parameter
is a list, then it contains the vector \code{rho_values} and the matrix
\code{P}, the second scenario when the type is a vector, then this object
contains the rho values, within this function the
\code{\link{high_dimension}} function is called to get the matrix \code{P}.
The last scenario that is when this object is set to \code{NULL}, i.e., the
\code{\link{rho_optim_bst}} function is called to get the rho values
(given a fixed perplexity) and the probabilities matrix. Optional parameter,
defaults to \code{NULL}).}

\item{rho}{parameter of the low-dimensional spherical Cauchy
probabilities. Optional, defaults to \code{0.5}).}

\item{perplexity}{parameter that measures the number of neighbors to
use when mapping between high- and low-dimension. Defaults to \code{30}).}

\item{maxit}{maximum number of iterations. Defaults to \code{1e3}).}

\item{initial_momentum}{first value of the momentum of the first \code{250}
iterations. Defaults to \code{0.5}.}

\item{final_momentum}{momentum to take into account after the \code{250}
iteration. Defaults to \code{0.8}.}

\item{eta}{is the learning rate of the optimization algorithm. Optional
param, defaults to \code{200}.}

\item{early_exaggeration}{the first \code{100} iterations results are
exaggerated by this factor. Optional parameter, defaults to \code{4.0}).}

\item{colors}{list with as many elements as observations are, only valid
when visualization is true. Optional parameter, defaults to \code{NULL}).}

\item{show_prog}{defines the number of iterations skipped when reporting
the progress. Defaults to \code{100}, i.e., only multiples of \code{100}
are reported. If \code{FALSE}, no progress is shown at all.}

\item{show_plots}{show convergence plots? If \code{TRUE} (default),
a plot is shown: after \code{2 * show_prog} iterations and at the end
of the search.}

\item{tol}{is the tolerance, when is below this value it is considered that
a good solution has been obtained. Defaults to \code{1e-6}).}

\item{parallel_cores}{number of cores to use concurrently for the
calculation of the gradient. Defaults to \code{parallel::detectCores() - 1},
that means that uses the total number of cores of the computer except one of
them.}

\item{init}{how to initialize the scores: \code{"equispaced"} (evenly spaced
points on the circumference/sphere), \code{"random"} (random points
generated uniformly), \code{"most_promising"} (best configuration
obtained in \code{N} differently-initialized searches run with
\code{maxit / 100} iterations), or a matrix. Defaults to \code{"equispaced"}.}

\item{N}{number of differently-initialized searches (see above). Defaults to
\code{10}.}
}
\value{
A list with the following entries:
\itemize{
  \item \code{best_Y}: best configuration of scores found.
  \item \code{last_Y}: last configuration of scores found.
  \item \code{rho_psc_list}: vector or rho's.
  \item \code{diagnostics}: data frame with the objective function values,
  absolute/relative errors, gradient norms, and moment norms.
  \item \code{convergence}: convergence flag.
}
}
\description{
Calculates the polyspherical-Cauchy SNE given a data onto the
polysphere and the reduced dimension.
}
\details{
When \code{init = "most_promising"}, \code{N - 1} initializations are random
and one is an equispaced grid.
}
\examples{
X <- sphunif::r_unif_sph(n = 100, p = 3, M = 3)
X[1:50, , 1] <- rotasym::r_vMF(n = 50, mu = c(0, 0, 1), kappa = 10)
X[51:100, , 1] <- rotasym::r_vMF(n = 50, mu = c(0, 0, -1), kappa = 10)
psc <- psc_sne(X = X, d = 1, parallel_cores = 2, eta = 50,
               init = "most_promising")
psc2 <- psc_sne(X = X, d = 1, parallel_cores = 2, eta = 50,
                init = psc$last_Y)
}
