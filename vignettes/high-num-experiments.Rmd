---
title: "High-dimensional Numerical Examples"
author: "Luis Ángel Rodríguez García"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{High-dimensional Numerical Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(pscsne)
library(rotasym)
library(sphunif)
library(abind)
library(rgl)
library(mvtnorm)
```

Numerical experiments are important for testing our algorithm since it can be identify whether the function is providing good results or not. Then, this document contains information about the simulation of high-dimensional data and defines different cases in each point.

First, we start with $p = 100$ and $r = 1$ where $(\mathbb{S}^{p})^r$.

## \boldmath $\mathbb{S}^{100}$ \unboldmath

Let us introduce some different scenarios where each of them has some particular distributions.

### A mixture of a small circle distribution and uniform distribution

```{r cache = TRUE}
sc_unif_mix <- function(n, p, w_sc, w_unif, kappa = 50) {
  if (w_sc + w_unif != 1) {
    
    stop("w_sc and w_unif must sum 1")
    
  }
  colors <- c()
  weights <- runif(n)
  rows <- lapply(1:n, function(i){
    w <- weights[i]
    if (w <= w_sc) {
      
      sphunif::r_alt(n = 1, p = p, alt = "SC", kappa = kappa)[ , , 1]
      
    } else {
      
      sphunif::r_unif_sph(n = 1, p = p)[ , , 1]
      
    }
  })
  data <- array(data = do.call(rbind, rows), dim = c(n, p, 1))
  return(list("data" = data, "colors" = ifelse(weights <= w_sc, 1, 2)))
}

n <- 1200
p <- 101
w_sc <- 0.5
w_unif <- 0.5
kappa <- 1000

sc_unif_mix_res <- sc_unif_mix(n = n, p = p, w_sc = w_sc, w_unif = w_unif, 
                               kappa = kappa)

sc_unif_mix_data <- sc_unif_mix_res$data
sc_unif_mix_colors <- sc_unif_mix_res$colors
```

Let's now run our algorithm and see if it identifies each component of the mixture. The previous step is to calculate the rho values based on a perplexity of 30.

```{r cache = TRUE}

rho_30_1 <- rho_optim_bst(x = sc_unif_mix_data, perp_fixed = 30, num_cores = 2)

```

The next thing is to run the algorithm with the parameter $d = 1$:

```{r}
res_pscsne_11 <- psc_sne(X = sc_unif_mix_data, d = 1, rho_psc_list = rho_30_1, 
                         num_iteration = 500, show_prog = TRUE, 
                         colors = sc_unif_mix_colors, parallel_cores = 2)
```

The next thing is to run the algorithm with the parameter $d = 2$:

```{r}
res_pscsne_12 <- psc_sne(X = sc_unif_mix_data, d = 2, rho_psc_list = rho_30_1, 
                         num_iteration = 500, show_prog = TRUE, 
                         colors = sc_unif_mix_colors, parallel_cores = 2)
```

```{r}
Y <- res_pscsne_12$best_Y
rgl::plot3d(0, 0, 0, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
             radius = 1, type = "s", col = "lightblue", alpha = 0.8, lit = FALSE)
rgl::points3d(Y, col = sc_unif_mix_colors)
```


### An example in variable selection

Defining 5 groups of 20 variables that are strongly correlated between them. For example, consider 
$$
(\mathbf{X}_{1},\ldots,\mathbf{X}_{5})'\sim\mathcal{N}_{100}(\boldsymbol{\mu},\boldsymbol{\Sigma}),
$$ 
where 
$$
\boldsymbol{\Sigma}=\mathrm{diag}(\boldsymbol{\Sigma}_{1},\ldots,\boldsymbol{\Sigma}_{5})
$$ 
is blockwise diagonal. Take now $n=200$ observations and center and standardize the features. Then the features now live in $\mathbb{S}^{n-1}$. 

Run pscsne on the standardized features on $\mathbb{S}^{199}$ for 100 observations. Then, we consider 10 groups of 20 variables each of them with positive correlation.

```{r}
# Visualize some features
n <- 100
g <- 5
p <- 20
x <- r_block(n = n, g = g, p = p)
pairs(x[, c(1:2, p + 1:2, (2 * p) + 1:2)], 
      labels = c("Var 1", "Var 2", paste("Var", p + 1), paste("Var", p + 2),
                 paste("Var", (2 * p) + 1), paste("Var", (2 * p) + 2)))

# Standardize variables -- now the vectors of observations for each variable
# (the columns) live on \sqrt{n - 1} * S^{n - 1}!
x_sca <- scale(x)

# Make the features live on S^{n - 1}
x_sca <- x_sca / sqrt(n - 1)

# Transpose matrix (features become observations)
feat_data <- t(x_sca)

# Colors of the groups
cols <- rep(1:g, each = p)

# Set an array of dimension c(g * p, n, 1)
dim(feat_data) <- c(dim(feat_data), 1)

# Change the order of the data
indexes <- sample(1:(g * p))
feat_data <- feat_data[indexes, , ,drop = FALSE]
cols <- cols[indexes]


```

Let's calculate the rho based on a perplexity of 30

```{r}
rho_list <- rho_optim_bst(x = feat_data, perp_fixed = 30, num_cores = 2)
```

Run psc_sne() with colors being the groups of variables.

```{r}
res_pscsne_21 <- psc_sne(X = feat_data, d = 1, rho_psc_list = rho_list, 
                      colors = cols, show_prog = T, num_iteration = 775, 
                      eta = 35, parallel_cores = 2)

```



```{r}
psc_sne_res_22 <- psc_sne(feat_data, d = 2, rho_psc_list = rho_list, colors = cols, 
                       num_iteration = 775, show_prog = TRUE, eta = 35, 
                       parallel_cores = 2)

```
```{r}
rgl::plot3d(0, 0, 0, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
             radius = 1, type = "s", col = "lightblue", alpha = 0.8, lit = FALSE)
rgl::points3d(psc_sne_res_22$best_Y, col = cols)
```

Let's do the same but know we are taking correlations negative and positive. 

```{r}
# Visualize some features
n <- 100
g <- 5
p <- 20
rho_values_neg <- rep(c(-0.9, 0.9), times = g)[1:g]
x <- r_block(n = n, g = g, p = p, rho = rho_values_neg)
pairs(x[, c(1:2, p + 1:2, (2 * p) + 1:2)], 
      labels = c("Var 1", "Var 2", paste("Var", p + 1), paste("Var", p + 2),
                 paste("Var", (2 * p) + 1), paste("Var", (2 * p) + 2)))

# Standardize variables -- now the vectors of observations for each variable
# (the columns) live on \sqrt{n - 1} * S^{n - 1}!
x_sca <- scale(x)

# Make the features live on S^{n - 1}
x_sca <- x_sca / sqrt(n - 1)

# Transpose matrix (features become observations)
feat_data_2 <- t(x_sca)

# Colors of the groups
cols <- rep(1:g, each = p)

# Set an array of dimension c(g * p, n, 1)
dim(feat_data_2) <- c(dim(feat_data_2), 1)

# Change the order of the data
indexes <- sample(1:(g * p))
feat_data_2 <- feat_data_2[indexes, , ,drop = FALSE]
cols <- cols[indexes]

```

Let's calculate the rho based on a perplexity of 30

```{r}
rho_list_2 <- rho_optim_bst(x = feat_data_2, perp_fixed = 30, num_cores = 2)
```

Run psc_sne() with colors being the groups of variables. First, reduced the data on the circumference.

```{r}
res_pscsne_21_neg <- psc_sne(X = feat_data_2, d = 1, rho_psc_list = rho_list_2, 
                      colors = cols, show_prog = T, num_iteration = 775, 
                      eta = 35, parallel_cores = 2)

```

Later on, reduced on the sphere $d = 2$.

```{r}
psc_sne_res_22_neg <- psc_sne(feat_data_2, d = 2, rho_psc_list = rho_list_2, 
                              colors = cols, num_iteration = 775, 
                              show_prog = TRUE, eta = 35, parallel_cores = 2)

```

Looks those results on the interactive sphere.

```{r}
rgl::plot3d(0, 0, 0, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
             radius = 1, type = "s", col = "lightblue", alpha = 0.8, lit = FALSE)
rgl::points3d(psc_sne_res_22_neg$best_Y, col = cols)
```

## \boldmath $(\mathbb{S}^{1})^{100}$ \unboldmath

### Generating samples that are uniform and independent in all 's except in the first five, where two groups are defined by two antipodal vMF distributions at north/south

A medium concentration (not massive, so that one has to rely on the combined information of the first ones).

```{r cache = TRUE}
r1 <- 5
r2 <- 95
p <- 1
n <- 100
kappa <- 1
gen_data <- rbinom(n = n, size = n, prob = 0.5)

x_vMF_5 <- sapply(seq_len(r1), function(k1) {
  data_vMF <- lapply(seq_len(n), function(i) {
    if(gen_data[i] <= n / 2) {
      
      rotasym::r_vMF(n = 1, mu = c(0, 1), kappa = kappa)
      
    } else {
      
      rotasym::r_vMF(n = 1, mu = c(0, -1), kappa = kappa)
      
    }
  })
  do.call(rbind, data_vMF)
   
}, simplify = 'array')

x_uniform_95 <- sphunif::r_unif_sph(n = n, p = p + 1, M = r2)

x_s1_100 <- abind(x_vMF_5, x_uniform_95, along = 3)

```

Let's calculate the rho based on a fixed perplexity of 30.

```{r cache = TRUE}
rho_30_s1_100 <- rho_optim_bst(x = x_s1_100, perp_fixed = 30, num_cores = 2)
```

First, let's reduce the dimension to the circumference:

```{r}
cols <- ifelse(gen_data <= n / 2, 2, 3)
psc_sne_res_31 <- psc_sne(X = x_s1_100, d = 1, rho_psc_list = rho_30_s1_100, 
                          colors = cols, show_prog = T, num_iteration = 775, 
                          eta = 25, parallel_cores = 2)
```

Later on, let's reduce the dimension to the sphere:

```{r}
psc_sne_res_32 <- psc_sne(X = x_s1_100, d = 2, rho_psc_list = rho_30_s1_100, 
                          colors = cols, show_prog = T, num_iteration = 775, 
                          eta = 25, parallel_cores = 2)
```

Let's visualize the results in the sphere:

```{r}
rgl::plot3d(0, 0, 0, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
             radius = 1, type = "s", col = "lightblue", lit = FALSE)
rgl::points3d(psc_sne_res_32$best_Y, col = cols)
``` 

### A path in $(\mathbb{S}^1)^{100}$ indexed by time.

For example, generated by 
$$
\theta_i(t)=(\alpha_i+2\pi k_i t) \mod 2\pi,\quad t\in[0,1], k_i\in\mathbb{Z}, \alpha_i\in[0,2\pi).
$$
These are wrapped straight lines with different slopes and starting points.

```{r cache = TRUE}
n <- 100
r <- 100
x_s1_100_path <- r_path_s1r(n = n, r = r)
cols <- rainbow(n, alpha = 1)

# Change the order of the data
indexes <- sample(1:n)
x_s1_100_path <- x_s1_100_path[indexes, , ]
cols <- cols[indexes]
```

Now that we have created the data, we can calculate the rho based on a fixed perplexity.

```{r cache = TRUE}
rho_30_s1_100_path <- rho_optim_bst(x = x_s1_100_path, perp_fixed = 30, 
                                    num_cores = 2)
```

First, let's reduce the dimension to the circumference:

```{r}
psc_sne_res_41 <- psc_sne(X = x_s1_100_path, d = 1, 
                          rho_psc_list = rho_30_s1_100_path, colors = cols, 
                          show_prog = T, num_iteration = 775, eta = 25, 
                          parallel_cores = 2)
```

Afterwards, let's get the results on the sphere:

```{r}
psc_sne_res_42 <- psc_sne(X = x_s1_100_path, d = 2, 
                          rho_psc_list = rho_30_s1_100_path, colors = cols, 
                          show_prog = T, num_iteration = 775, eta = 25, 
                          parallel_cores = 2)
```

Let's visualize the results in the sphere:

```{r}
rgl::plot3d(0, 0, 0, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
             radius = 1, type = "s", col = "lightblue", lit = FALSE)
rgl::points3d(psc_sne_res_42$best_Y, col = cols)
```

## \boldmath $(\mathbb{S}^2)^{100}$ \unboldmath

Generate samples that are uniform and independent in all $\mathbb{S}^2$ except in the first five, where there is a common time-indexed path given by 
$$
x_1(t)=\text{equator},
$$ 
$$
x_2(t)=\text{small-circle-rotated-1},
$$ 
$$
x_3(t)=\text{small-circle-rotated-2},
$$ 
$$
x_4(t)=\text{spherical-spiral-1},
$$ 
$$
x_5(t)=\text{spherical-spiral-2}.
$$ 
Use [spherical spirals](https://en.wikipedia.org/wiki/Spiral#Spherical_spirals).

```{r cache = TRUE}
n <- 100
r1 <- 1
r2 <- 2
r3 <- 2
r4 <- 95

# Calculate the north pole of the sphere
theta <- (90 * pi) / (180)
phi <- (0 * pi) / (180)
north_pole <- t(DirStats::to_sph(th = c(theta), ph = c(phi)))

# small circle in the equator (1 sample)
samp_1 <- r_path_s2r(n = n, r = r1, sigma = 0.1, Theta = north_pole)
# small circle rotated 1 and 2 (2 samples)
samp_2_3 <- r_path_s2r(n = n, r = r2, sigma = 0.1)
# spherical spiral 1 and 2 (2 samples)
samp_4_5 <- r_path_s2r(n = n, r = r3, c = 3, spiral = TRUE, sigma = 0.01)
# Data following an uniform distribution on the sphere (95 samples)
samp_95 <- r_unif_sph(n = n, p = 3, M = r4)

x_s2_100 <- abind(samp_1, samp_2_3, samp_4_5, samp_95, along = 3)
cols = rainbow(n, alpha = 1)

# Change the order of the data
indexes <- sample(1:n)
x_s2_100 <- x_s2_100[indexes, , ]
cols <- cols[indexes]
```

Now that we have created the artificial dataset, we can calculate the rho based on a fixed perplexity.

```{r cache = TRUE}
rho_30_s2_100 <- rho_optim_bst(x = x_s2_100, perp_fixed = 30, num_cores = 2)

```

First, let's reduce the dimension to the circumference:

```{r}
psc_sne_res_51 <- psc_sne(X = x_s2_100, d = 1, rho_psc_list = rho_30_s2_100, 
                          colors = cols, show_prog = T, num_iteration = 775,
                          eta = 25, parallel_cores = 2)
```

Afterwards, let's get the results on the sphere:

```{r}
psc_sne_res_52 <- psc_sne(X = x_s2_100, d = 2, rho_psc_list = rho_30_s2_100, 
                          colors = cols, show_prog = T, num_iteration = 775, 
                          eta = 25, parallel_cores = 2)
```

Let's visualize the results in the sphere:

```{r}
rgl::plot3d(0, 0, 0, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
             radius = 1, type = "s", col = "lightblue", lit = FALSE)
rgl::points3d(psc_sne_res_52$best_Y, col = cols)
```
